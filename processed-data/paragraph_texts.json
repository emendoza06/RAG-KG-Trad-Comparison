["= introduction to neo4j & genai\n:order: 1\n:type: lesson\n\nthis course will get you started learning about using neo4j with generative ai.\n\nyou will learn about:\n\n* large language models (llms)\n* knowledge graphs\n* how to use neo4j for retrieval augmented generation (rag)\n* integrating neo4j and llms using python and langchain\n\nfirst, let's cover the basics.\n\n== what is neo4j?\n\nneo4j is a graph database and analytics system that allows us to store, manage, and query highly connected data.\n\nunlike traditional relational databases, which use tables and rows, neo4j uses a graph-based model with nodes and relationships.\n\nimage::images/large-social-graph.jpg[a visualization of a graph showing nodes connected by relationships]\n\nmaking neo4j particularly well-suited for representing and querying complex, interconnected data.\n\n[tip]\n.new to neo4j?\nto learn about graph databases and neo4j, check out the  link:/courses/neo4j-fundamentals/[graphacademy neo4j fundamentals course^].\n\n== what are knowledge graphs?\n\nknowledge graphs are a specific implementation of a graph database, where information is captured and integrated from many different sources, representing the inherent knowledge of a particular domain.\n\nthey provide a structured way to represent entities, their attributes, and their relationships, allowing for a comprehensive and interconnected understanding of the information within that domain.", "they provide a structured way to represent entities, their attributes, and their relationships, allowing for a comprehensive and interconnected understanding of the information within that domain.\n\nknowledge graphs break down sources of information and integrate them, allowing you to see the relationships between the data.\n\nimage::images/generic-knowledge-graph.svg[a diagram of an abstract knowledge graph showing how sources contain chunks of data about topics which can be related to other topics]\n\nyou can tailor knowledge graphs for semantic search, data retrieval, and reasoning. \n\nyou may not be familiar with the term knowledge graph, but you have probably used one. search engines typically use knowledge graphs to provide information about people, places, and things.\n\nthe following knowledge graph could represent neo4j:\n\nimage::images/neo4j-google-knowledge-graph.svg[an example of a knowledge graph of neo4j showing the relationships between people, places, and things]\n\nthis integration from diverse sources gives knowledge graphs a more holistic view and facilitates complex queries, analytics, and insights.\n\n[tip]\n.knowledge graphs and ontologies\nfor more on knowledge graphs, ontologies, we recommend watching the\nlink:https://www.youtube.com/watch?v=nqqwbnyqls4&list=pl9hl4pk2fsvx-5qpvwchb-ni_mff97rce[going meta \u00e2\u20ac\u201c a series on graphs, semantics and knowledge series on youtube^].", "knowledge graphs can readily adapt and evolve as they grow, taking on new information and structure changes.\n\n== large language models & generative ai\n\nlarge language models, referred to as llms, learn the underlying structure and distribution of the data and can then generate new samples that resemble the original data.\n\nllms are trained on vast amounts of text data to understand and generate human-like text. llms can answer questions, create content, and assist with various linguistic tasks by leveraging patterns learned from the data.\n\ngenerative ai is a class of algorithms and models that can generate new content, such as images, text, or even music. new content is generated based on user prompting, existing patterns, and examples from existing data.\n\n=== instructing an llm\n\nthe response generated by an llm is a probabilistic continuation of the instructions it receives. the llm provides the most likely response based on the patterns it has learned from its training data.\n\nin simple terms, if presented with the prompt _\"continue this sequence - a b c\"_, an llm could respond _\"d e f\"_.\n\nto get an llm to perform a task, you provide a **prompt**, a piece of text that should specify your requirements and provide clear instructions on how to respond.\n\nimage::images/llm-prompt-interaction.svg[a user asks an llm the question 'what is an llm? give the response using simple language avoiding jargon.', the llm responds with a simple definition of an llm.]", "precision in the task description, potentially combined with examples or context, ensures that the model understands the intent and produces relevant and accurate outputs.\n\nan example prompt may be a simple question.\n\n    what is the capital of japan?\n\nor, it could be more descriptive. for example:\n\n    tell me about the capital of japan.\n    produce a brief list of talking points exploring its culture and history.\n    the content should be targeted at tourists.\n    your readers may have english as a second language, so use simple terms and avoid colloquialisms.\n    avoid jargon at all costs.\n    return the results as a list of json strings containing content formatted in markdown.\n\nthe llm will interpret these instructions and return a response based on the patterns it has learned from its training data.\n\n== potential problems\n\nwhile llms provide a lot of potential, you should also be cautious.\n\nat their core, llms are trained to predict the following word(s) in a sequence.\n\nthe words are based on the patterns and relationships from other text in the training data. the sources for this training data are often the internet, books, and other publicly available text. this data could be of questionable quality and maybe be incorrect. training happens at a point in time, it may not reflect the current state of the world and would not include any private information.", "llms are fine-tuned to be as helpful as possible, even if that means occasionally generating misleading or baseless content, a phenomenon known as **hallucination**.\n\nfor example, when asked to _\"describe the moon.\"_ and llm may respond with _\"the moon is made of cheese.\"_. while this is a common saying, it is not true.\n\nimage::images/confused-llm.svg[a diagram of a confused llm with a question mark thinking about the moon and cheese.]\n\nwhile llms can represent the essence of words and phrases, they don't possess a genuine understanding or ethical judgment of the content.\n\nthese factors can lead to outputs that might be biased, devoid of context, or lack logical coherence.\n\n== fixing hallucinations\n\nproviding additional *contextual* data helps to _ground_ the llm's responses and make them more accurate.\n\na knowledge graph is a mechanism for providing additional data to an llm. data within the knowledge graph can guide the llm to provide more relevant, accurate, and reliable responses. \n\nwhile the llm uses its language skills to interpret and respond to the contextual data, it will not disregard the original training data.\n\nyou can think of the original training data as the base knowledge and linguistic capabilities, while the contextual information guides in specific situations.\n\nthe combination of both approaches enables the llm to generate more meaningful responses.", "the combination of both approaches enables the llm to generate more meaningful responses.\n\nthroughout this course, you will explore how to leverage the capabilities of neo4j and generative ai to build intelligent, context-aware systems.\n\nyou will apply the information and skills learned in the course to build an engine that provides recommendations and information about movies and people.\n\n== check your understanding\n\ninclude::questions/1-hallucination.adoc[leveloffset=+1]\ninclude::questions/2-fixing-hallucination.adoc[leveloffset=+1]\n\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned about llms, their benefits and challenges.\n\nin the next lesson, you will learn about hallucination and the strategies for avoiding it.", "= avoiding hallucination\n:order: 2\n:type: lesson\n\nas you learned in the previous lesson, llms can \"make things up\".\n\nllms are designed to generate human-like text based on the patterns they've identified in vast amounts of data. \n\ndue to their reliance on patterns and the sheer volume of training information, llms sometimes **hallucinate** or produce outputs that manifest as generating untrue facts, asserting details with unwarranted confidence, or crafting plausible yet nonsensical explanations.\n\nthese manifestations arise from a mix of _overfitting_, biases in the training data, and the model's attempt to generalize from vast amounts of information.\n\n== common hallucination problems\n\nlet's take a closer look at some reasons why this may occur.\n\n=== temperature\n\nllms have a _temperature_, corresponding to the amount of randomness the underlying model should use when generating the text.\n\nthe higher the temperature value, the more random the generated result will become, and the more likely the response will contain false statements.\n\na higher temperature may be appropriate when configuring an llm to respond with more diverse and creative outputs, but it comes at the expense of consistency and precision.\n\nfor example, a higher temperature may be suitable for constructing a work of fiction or a novel joke.\n\non the other hand, a lower temperature, even `0`, is required when a response grounded in facts is essential.", "on the other hand, a lower temperature, even `0`, is required when a response grounded in facts is essential.\n\n[tip]\n.consider the correct temperature\n====\nin june 2023, link:https://www.reuters.com/legal/new-york-lawyers-sanctioned-using-fake-chatgpt-cases-legal-brief-2023-06-22/[a us judged sanctioned two us lawyers for submitting an llm-generated legal brief^] that contained six fictitious case citations.\n====\n\na quick fix _may_ be to reduce the temperature. but more likely, the llm is hallucinating because it hasn't got the information required.\n\n=== missing information\n\nthe training process for llms is intricate and time-intensive, often requiring vast datasets compiled over extended periods. as such, these models might lack the most recent information or might miss out on specific niche topics not well-represented in their training data.\n\nfor instance, if an llm's last update were in september 2022, it would be unaware of world events or advancements in various fields that occurred post that date, leading to potential gaps in its knowledge or responses that seem out of touch with current realities.\n\nif the user asks a question on information that is hard to find or outside of the public domain, it will be virtually impossible for an llm to respond accurately.\n\nluckily, this is where factual information from data sources such as knowledge graphs can help.\n\n=== model training and complexity", "luckily, this is where factual information from data sources such as knowledge graphs can help.\n\n=== model training and complexity\n\nlarge language models (llms) are often considered \"black boxes\" due to the difficulty deciphering their decision-making processes.\n\nimage::images/llm-blackbox.svg[an llm as a black box, responding to the question 'how did you determine that answer?' with 'i don't know.']\n\nthe complexity of these models, combined with potential training on erroneous or misleading data, means that their outputs can sometimes be unpredictable or inaccurate.\n\nfor example, an llm might produce a biased or incorrect answer when asked about a controversial historical event. \n\nfurthermore, it would be near impossible to trace back how the model arrived at that conclusion. the llm would also be unable to provide the sources for its output or explain its reasoning.\n\n== improving llm accuracy\n\nthe following methods can be employed to help guide llms to produce more consistent and accurate results.\n\n=== prompt engineering\n\nprompt engineering is developing specific and deliberate instructions that guide the llm toward the desired response.\n\nby refining how you pose instructions, developers can achieve better results from existing models without retraining.\n\nfor example, if you require a blog post summary, rather than asking _\"what is this blog post about?\"_, a more appropriate response would be _\"provide a concise, three-sentence summary and three tags for this blog post.\"_", "you could also include _\"return the response as json\"_ and provide an example output to make it easier to parse in the programming language of your choice.\n\nproviding additional instructions and context in the question is known as **zero-shot learning**.\n\n[tip]\n.be positive\n====\nwhen writing a prompt, aim to provide positive instructions.\n\nfor example, when asking an expert to provide a description, you could say, \"do not use complex words.\" however, the expert's interpretation of complex might be different from yours. instead, say, \"use simple words, such as ....\". this approach provides a clear instruction and a concrete example.\n====\n\n=== in-context learning\n\nin-context learning provides the model with examples to inform its responses, helping it comprehend the task better.\n\nthe model can deliver more accurate answers by presenting relevant examples, especially for niche or specialized tasks.\n\nexamples could include:\n\n* providing additional context - `when asked about \"bats\", assume the question is about the flying mammal and not a piece of sports equipment.`  \n* providing examples of the typical input - `questions about capital cities will be formatted as \"what is the capital of {country}?\"`\n* providing examples of the desired output - `when asked about the weather, return the response in the format \"the weather in {city} is {temperature} degrees celsius.\"`\n\nproviding relevant examples for specific tasks is a form of **few-shot learning**.\n\n=== fine-tuning", "providing relevant examples for specific tasks is a form of **few-shot learning**.\n\n=== fine-tuning\n\nfine-tuning involves additional language model training on a smaller, task-specific dataset after its primary training phase. this approach allows developers to specialize the model for specific domains or tasks, enhancing its accuracy and relevance. \n\nfor example, fine-tuning an existing model on your particular businesses would enhance its capability to respond to your customer's queries.\n\nthis method is the most complicated, involving technical knowledge, domain expertise, and high computational effort.\n\na more straightforward approach would be to _ground_ the model by providing information with the prompt.\n\n=== grounding\n\ngrounding allows a language model to reference external, up-to-date sources or databases to enrich the responses.\n\nby integrating real-time data or apis, developers ensure the model remains current and provides factual information beyond its last training cut-off.\n\nfor instance, if building a chatbot for a news agency, instead of solely relying on the model's last training data, grounding could allow the model to pull real-time headlines or articles from a news api. when a user asks, \"what's the latest news on the olympics?\", the chatbot, through grounding, can provide a current headline or summary from the most recent articles, ensuring the response is timely and accurate.", "image::images/llm-news-agency.svg[a news agency chatbot, showing the user asking a question, the chatbot grounding the question with a news api, and the chatbot responding with the latest news.]\n\n== llms and knowledge graphs\n\nin the coming lessons, you will explore these topics in detail and discover how llms can use knowledge graphs to improve their accuracy and relevance.\n\n== check your understanding\n\ninclude::questions/1-temperature.adoc[leveloffset=+1]\ninclude::questions/2-external-data.adoc[leveloffset=+1]\n\n\n[.summary]\n== lesson summary\n\nin this lesson, you explored the intricacies of large language models (llms), understanding their tendencies to hallucinate and the various strategies to improve their accuracy, such as temperature settings, prompt engineering, in-context learning, fine-tuning, and grounding with external data sources like apis.\n\nin the next lesson, you will learn about the techniques for _grounding_ an llm.", "= grounding llms\n:order: 3\n:type: lesson\n\nin the previous lesson, you learned about the potential methods that you could use to avoid _hallucination_, including _grounding_.\n\ngrounding is the process of providing context to an llm to improve the accuracy of its responses. for developers and data scientists, grounding usually offers the highest impact for the lowest effort.\n\nyou reflected on an example chatbot for a news agency that pulled real-time headlines or articles from a news api.\n\nin this lesson, you will explore the news agency use case in more detail.\n\n== data cut-off dates\n\ntraining a large language model has a high computational cost. according to wikipedia, openai's gpt-3 model was link:https://en.wikipedia.org/wiki/gpt-3[trained on 175 billion parameters^], and the resulting trained model takes 800gb to store.\n\nretraining a model on new data would be expensive and time-consuming. a model may take weeks or months to train.\n\nproviding real-time updates on fast-moving breaking news would be out of the question.\n\n== retrieval augmented generation\n\na news agency could train a model on static data and supplement the pre-existing knowledge base with real-time data retrieved from up-to-date sources. \n\nthis approach is known as **retrieval augmented generation**, or **rag**", "this approach is known as **retrieval augmented generation**, or **rag**\n\nrag combines the strengths of large-scale language models with external retrieval or search mechanisms, enabling relevant information from vast datasets to be dynamically fed into the model during the generation process, thereby enhancing its ability to provide detailed and contextually accurate responses.\n\nin summary, by adding content from additional data sources, you can improve the responses generated by an llm.\n\n=== benefits of rag\n\nthe main benefit of rag is its **enhanced accuracy**. by dynamically pulling information from external, domain-specific sources, a response grounded by rag can provide more detailed and contextually accurate answers than a standalone llm.\n\nrag provides additional benefits of:\n\n* increased transparency, as the sources of the information can be stored and examined.\n* security, as the data sources can be secured and access controlled.\n* accuracy and timeliness, as the data sources can be updated in real-time.\n* access to private or proprietary data\n\n[warning]\n.bad data in, bad data out\n====\nwhen prompting the llm to respond based on the context provided, the answer will always be as good as the provided context.\n\nif your prompt suggests pineapple as a pizza topping, don't be surprised if it suggests that you order a hawaiian pizza.\n====\n\nrag could support the new agency chatbot by:", "if your prompt suggests pineapple as a pizza topping, don't be surprised if it suggests that you order a hawaiian pizza.\n====\n\nrag could support the new agency chatbot by:\n\n. accessing real-time new feeds\n. pulling recent headlines or news articles from a database,\n. giving this additional context to the llm\n\nnew articles stored in a knowledge graph would be ideal for this use case. a knowledge graph could pass the llm detail about the relationship between the entities involved and the article's metadata.\n\nfor example, when asking about the results of a recent election, the knowledge could provide additional context about the candidates, news stories relating to them, or interesting articles from the same author.\n\nimage::images/llm-news-agency-knowledge-graph.svg[a news agency chatbot using a knowledge graph to provide context to an llm. the knowledge graph takes data from a news api and previous articles.]\n\nduring this course, you will explore methods for implementing rag with neo4j, including:\n\n* semantic search\n* zero-shot and few-shot learning and prompts\n* text embedding and vector indexes with unstructured data\n* cypher generation to gather structured data from a knowledge graph\n\n\n== check your understanding\n\ninclude::questions/1-benefits.adoc[leveloffset=+1]\n\n\n[.summary]\n== lesson summary", "== check your understanding\n\ninclude::questions/1-benefits.adoc[leveloffset=+1]\n\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned about the importance of grounding to enhance llm accuracy, the computational challenges of constantly training large models, and how retrieval augmented generation (rag) combines llms with external data for improved responses with increased transparency.\n\nin the next module, you will learn how to implement semantic search and use vector indexes in neo4j.", "= vectors & semantic search\n:order: 1\n:type: lesson\n\nin the last module, you learned about the importance of grounding to improve llm accuracy and the concept of **retrieval augmented generation** (rag).\nrag involves providing additional information to help the llm form a response.\n\none of the challenges of rag is understanding what the user is asking for and surfacing the correct information to pass to the llm.\n\n\n== semantic search vs. traditional keyword search\n\nsemantic search aims to understand search phrases' intent and contextual meaning, rather than focusing on individual keywords.\n\ntraditional keyword search often depends on exact-match keywords or proximity-based algorithms that find similar words.\n\nfor example, if you input \"apple\" in a traditional search, you might predominantly get results about the fruit.\n\nhowever, in a semantic search, the engine tries to gauge the context: are you searching about the fruit, the tech company, or something else?\n\nthe results are tailored based on the term and the perceived intent.\n\n== vectors and embeddings\n\nin natural language processing (nlp) and machine learning, numerical representations (known as **vectors**) represent words and phrases.\n\neach dimension in a vector can represent a particular semantic aspect of the word or phrase. when multiple dimensions are combined, they can convey the overall meaning of the word or phrase.", "each dimension in a vector can represent a particular semantic aspect of the word or phrase. when multiple dimensions are combined, they can convey the overall meaning of the word or phrase.\n\na vector will not directly encode tangible attributes like color, taste, or shape.\ninstead, the model will generate a list of numerical values that closely align the word with related words such as health, nutrition, and wellness.\n\nwhen applied in a search context, the vector for \"apple\" can be compared to the vectors for other words or phrases to determine the most relevant results.\n\nyou can create vectors in various ways, but one of the most common methods is to use a **large language model**. these vectors are known as **embeddings**. with advanced models, these embeddings also contain contextual information.\n\nfor example, the embeddings for the word \"apple\" are `0.0077788467, -0.02306925, -0.007360777, -0.027743412, -0.0045747845, 0.01289164, -0.021863015, -0.008587573, 0.01892967, -0.029854324, -0.0027962727, 0.020108491, -0.004530236, 0.009129008,` ... and so on.\n\n[%collapsible]\n.reveal the completed embeddings for the word \"apple\"!\n====\n[source]\n----\ninclude::includes/apple.txt[]\n----\n====\n\nthe vector for a word can change based on its surrounding context. for instance, the word _bank_ will have a different vector in _river bank_ than in _savings bank_.\n\nsemantic search systems can use these contextual embeddings to understand user intent.", "semantic search systems can use these contextual embeddings to understand user intent.\n\n[note]\n.creating vector embeddings\n====\nllm providers typically expose api endpoints that convert a _chunk_ of text into a vector embedding.\ndepending on the provider, the shape and size of the vector may differ.\n\nfor example, openai's `text-embedding-ada-002` embedding model converts text into a vector of 1,536 dimensions.\n====\n\nyou can use the _distance_ or _angle_ between vectors to gauge the semantic similarity between words or phrases.\n\nimage::images/vector-distance.svg[a 3 dimensional chart illustrating the distance between vectors. the vectors are for the words \"apple\" and \"fruit\"]\n\nwords with similar meanings or contexts will have vectors that are close together, while unrelated words will be farther apart.\n\nthis principle is employed in semantic search to find contextually relevant results for a user's query.\n\na semantic search involves the following steps:\n\n. the user submits a query.\n. the system creates a vector representation (embedding) of the query.\n. the system compares the query vector to the vectors of the indexed data.\n. the results are scored based on their similarity.\n. the system returns the most relevant results to the user.\n\nimage::images/semantic-vector-search.svg[a diagram show the steps of a semantic search.]", "image::images/semantic-vector-search.svg[a diagram show the steps of a semantic search.]\n\nvectors can represent more than just words. they can also represent entire documents, images, audio, or other data types. they are instrumental in the operation of many other machine-learning tasks.\n\n\n== vectors and neo4j\n\nvectors are the backbone of semantic search. they enable systems to understand and represent the complex, multi-dimensional nature of language, context, and meaning.\n\nsince the v5.11 release, neo4j has a link:https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/[vector search index^], allowing you to query for nodes based on their vector representations.\n\nin the next lesson, you will learn how to use vectors to implement semantic search in neo4j.\n\n[.checklist]\n\n== check your understanding\n\ninclude::questions/1-semantic-vs-traditional.adoc[leveloffset=+1]\ninclude::questions/2-vector-role.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned how semantic search differs from traditional keyword search. vectors, representing data numerically, facilitate this advanced search mechanism and are integral to many machine learning algorithms like llms.\n\nin the next lesson, you will learn how to use vector indexes in neo4j and implement semantic search.", "= vector indexes\n:order: 2\n:type: lesson\n:sandbox: true\n\nin the last lesson, you learned about vectors and their role in semantic search.\n\nin this lesson, you will learn how to create vector embeddings of text content in an existing neo4j database.\n\n== vectorizing movie plots\n\ngraphacademy created a movie recommendation sandbox when you enrolled in this course. the sandbox database contains over 9000 movies, 15000 actors, and over 100000 user ratings.\n\neach movie has a `.plot` property.\n\n.movie plot example\n[source,cypher]\nmatch (m:movie {title: \"toy story\"})\nreturn m.title as title, m.plot as plot\n\n    \"a cowboy doll is profoundly threatened and jealous when a new spaceman figure supplants him as top toy in a boy's room.\"\n\nyou can use the vector index to find the most similar movies by converting the plots into vector embeddings and comparing them.\n\nyou will use a pre-created link:https://data.neo4j.com/llm-fundamentals/openai-embeddings.csv[csv file of 1000 movie plot vector embeddings^] in this lesson.\n\nthe csv file contains:\n\n* `movieid` - the id of the movie\n* `embedding` - the vector embedding of the movie plot generated by openai\n\n[source,csv]\n----\nmovieid, embedding\n1, [-0.0271058, -0.0242211, 0.0060390322, -0.02437703, ...]\n2, [-0.001596838, -0.022397375, 0.0046575777, 0.0019427929, ...]\n----", "[source,csv]\n----\nmovieid, embedding\n1, [-0.0271058, -0.0242211, 0.0060390322, -0.02437703, ...]\n2, [-0.001596838, -0.022397375, 0.0046575777, 0.0019427929, ...]\n----\n\n[tip]\n.generating the embeddings\n====\nlink:https://platform.openai.com/docs/guides/embeddings/what-are-embeddings[openai's text-embedding-ada-002 model^] was used to create the embeddings. it is a cost-effective model that can generate embeddings for text.\n\na simple python script calls the embedding endpoint served by openai. the link:https://github.com/neo4j-graphacademy/llm-fundamentals/blob/main/plot_openai_embeddings.py[code^] is available in the link:https://github.com/neo4j-graphacademy/llm-fundamentals[github.com/graphacademy/llm-fundamentals^] repository.\n\neach llm will provide an embedding in its shape. \n====\n\n== loading embeddings\n\nthe embeddings will be stored as a `.embedding` property on the `(:movie)` node.\n\nyou will use the `load csv` command to load the embeddings into the neo4j sandbox instance.\n\nthe following cypher loads the embeddings csv file, performs a `match` query to find the `(:movie)` node with the corresponding `movieid` property, and then sets the `.embedding` property on that node.\n\nreview this cypher statement before running it.", "review this cypher statement before running it.\n\n.loading the embeddings\n[source,cypher]\n----\nload csv with headers\nfrom 'https://data.neo4j.com/llm-fundamentals/openai-embeddings.csv'\nas row\nmatch (m:movie {movieid: row.movieid})\ncall db.create.setnodevectorproperty(m, 'embedding', apoc.convert.fromjsonlist(row.embedding))\nreturn count(*)\n----\n\nthe statement:\n\n* loads the csv file\n* matches the `(:movie)` node with the corresponding `movieid` property\n* calls `db.create.setnodevectorproperty()` procedure to set the `embedding` property\n* the procedure also validates that the property is a valid vector\n\nrun the statement to create the movie embeddings.\n\nonce complete, you can query the database to see the `.embedding` property on the `(:movie)` nodes.\n\n[source,cypher]\nmatch (m:movie {title: \"toy story\"})\nreturn m.title as title, m.plot as plot, m.embedding\n\n[tip]\n.load csv and strings\n====\nwhen data is loaded using `load csv`, it is treated as a string unless specifically cast using a specific function, for example, `tointeger()` or `tofloat()`.\n\nin this case, the embedding is a string representing a json list, the statement coerces it into a cypher `list` link:https://neo4j.com/docs/apoc/current/overview/apoc.convert/apoc.convert.fromjsonlist/[using the `apoc.convert.fromjsonlist()` procedure^].\n\nyou can link:https://graphacademy.neo4j.com/courses/importing-cypher/[learn how to use the `load csv` command in the importing csv data into neo4j course^].\n====", "you can link:https://graphacademy.neo4j.com/courses/importing-cypher/[learn how to use the `load csv` command in the importing csv data into neo4j course^].\n====\n\n== creating the vector index\n\nyou will need to create a vector index to search across these embeddings.\n\nyou will use the `create vector index` cypher statement to create the index:\n\n.create vector index syntax\n[source,cypher, role=noplay nocopy]\n----\ncreate vector index [index_name] [if not exists]\nfor (n:labelname)\non (n.propertyname)\noptions \"{\" option: value[, ...] \"}\"\n----\n\n`create vector index` expects the following parameters:\n\n* `index_name` - the name of the index\n* `labelname` - the node label on which to index\n* `propertyname` - the property on which to index\n* `options` - the options for the index, where you can specify:\n** `vector.dimensions` - the dimension of the embedding e.g. openai embeddings consist of `1536` dimensions.\n** `vector.similarity_function` - the similarity function to use when comparing values in this index - this can be `euclidean` or `cosine`.\n\nreview and run the following cypher to create the vector index:\n\n.create the vector index\n[source,cypher]\n----\ncreate vector index movieplots if not exists\nfor (m:movie)\non m.embedding\noptions {indexconfig: {\n `vector.dimensions`: 1536,\n `vector.similarity_function`: 'cosine'\n}}\n----", "note that the index is called `movieplots`, it is against the `movie` label, and it is on the `.embedding` property. the `vector.dimensions` is `1536` (as used by openai) and the `vector.similarity_function` is `cosine`. the `if not exists` clause ensures that the statement only creates the index if it does not already exist.\n\nrun the statement to create the index.\n\n[tip]\n.choosing a similarity function\n====\ngenerally, cosine will perform best for text embeddings, but you may want to experiment with other functions.\n\nyou can link:https://neo4j.com/docs/cypher-manual/current/indexes-for-vector-search/#indexes-vector-similarity[read more about similarity functions in the documentation^].\n\ntypically, you will choose a similarity function closest to the loss function used when training the embedding model. you should refer to the model's documentation for more information.\n====\n\n=== check the index creation status\n\nthe index will be updated asynchronously. you can check the status of the index population using the `show indexes` statement:\n\ncheck that you created the index successfully using the `show indexes` command.\n\n.show indexes\n[source,cypher]\n----\nshow indexes  yield id, name, type, state, populationpercent where type = \"vector\"\n----\n\nyou should see a result similar to the following:\n\n.show indexes result\n|===\n| id | name | type | state | populationpercent\n\n|1 | \"movieplots\" | \"vector\" | \"online\" | `100.0`\n|===", "you should see a result similar to the following:\n\n.show indexes result\n|===\n| id | name | type | state | populationpercent\n\n|1 | \"movieplots\" | \"vector\" | \"online\" | `100.0`\n|===\n\nonce the `state` is listed as online, the index will be ready to query.\n\nthe `populationpercentage` field indicates the proportion of node and property pairing.\n\nwhen the `populationpercentage` is `100.0`, all the movie embeddings have been indexed.\n\n== querying vector indexes\n\nyou can query the index using the `db.index.vector.querynodes()` procedure.\n\nthe procedure returns the requested number of approximate nearest neighbor nodes and their similarity score, ordered by the score.\n\n.db.index.vector.querynodes syntax\n[source,cypher,role=nocopy noplay]\n----\ncall db.index.vector.querynodes(\n    indexname :: string,\n    numberofnearestneighbours :: integer,\n    query :: list<float>\n) yield node, score\n----\n\nthe procedure accepts three parameters:\n\n1. `indexname` - the name of the vector index\n2. `numberofnearestneighbours` - the number of results to return\n3. `query` - a list of floats that represent an embedding\n\nthe procedure yields two arguments: \n\n. a `node` which matches the query\n. a similarity `score` ranging from `0.0` to `1.0`.\n\n// todo - mh comment - should we also show how to search for a user question embedding? should we prepare a few in a file?\n\nyou can use this procedure to find the closest embedding value to a given embedding.\n\nfor example, find movies with a similar plot to another.", "you can use this procedure to find the closest embedding value to a given embedding.\n\nfor example, find movies with a similar plot to another.\n\nreview this cypher before running it.\n\n[source,cypher]\n.similar plots\n----\nmatch (m:movie {title: 'toy story'})\n\ncall db.index.vector.querynodes('movieplots', 6, m.embedding)\nyield node, score\n\nreturn node.title as title, node.plot as plot, score\n----\n\nthe query finds the _toy story_ `movie` node and uses the `.embedding` property to find the most similar plots. the `db.index.vector.querynodes()` procedure uses the `movieplots` vector index to find similar embeddings.\n\nrun the query. the procedure returns the requested number of approximate nearest neighbor nodes and their similarity score, ordered by the score.", "run the query. the procedure returns the requested number of approximate nearest neighbor nodes and their similarity score, ordered by the score.\n\n.similar plots results\n|===\n| title | plot | score\n| \"toy story\" | \"a cowboy doll is profoundly threatened and jealous when a new spaceman figure supplants him as top toy in a boy's room.\" | 1.0\n| \"little rascals, the\" | \"alfalfa is wooing darla and his he-man-woman-hating friends attempt to sabotage the relationship.\" | 0.9214372634887695\n| \"neverending story iii, the\" | \"a young boy must restore order when a group of bullies steal the magical book that acts as a portal between earth and the imaginary world of fantasia.\" | 0.9206198453903198\n|  \"drop dead fred\" | \"a young woman finds her already unstable life rocked by the presence of a rambunctious imaginary friend from childhood.\" | 0.9199690818786621\n| \"e.t. the extra-terrestrial\" | \"a troubled child summons the courage to help a friendly alien escape earth and return to his home-world.\" | 0.919100284576416\n| \"gumby: the movie\" | \"in this offshoot of the 1950s claymation cartoon series, the crazy blockheads threaten to ruin gumby's benefit concert by replacing the entire city of clokeytown with robots.\" | 0.9180967211723328\n|===\n\nthe similarity score is between `0.0` and `1.0`, with `1.0` being the most similar. note how the most similar plot is that of the _toy story_ movie itself!\n\n== considerations", "the similarity score is between `0.0` and `1.0`, with `1.0` being the most similar. note how the most similar plot is that of the _toy story_ movie itself!\n\n== considerations\n\nas you can see, this approach is relatively straightforward and can quickly yield results. the downside to this approach is that it relies heavily on the embeddings and similarity function to produce valid results.\n\nthis approach is also a black box - with 1536 dimensions, and it would be impossible to determine how the vectors are structured and how they influenced the similarity score.\n\nthe movies returned look similar, but without reading and comparing them, you would have no way of verifying that the results are correct.\n\n== check your understanding\n\ninclude::questions/1-create-index.adoc[leveloffset=+1]\ninclude::questions/2-query-index.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned how to create, populate, and use a vector index in neo4j.\n\nin the next lesson, you will learn how to use feedback to improve the suggestions provided by semantic search.", "= improving semantic search\n:order: 3\n:type: lesson\n:optional: true\n\nin this module, you have learned about the benefits and drawbacks of semantic search using an underlying vector index.\n\nyou received an answer when querying the vector index for a similar movie, but it is difficult to tell whether that is the best movie in the database.\n\nwhen using vector-backed semantic search, you are placing a lot of emphasis on the underlying model to provide a good similarity.\n\nthe context from which the similarity scores are provided is an important factor here.\n\nthe embeddings were trained on a generic dataset, and as such, may identify two movies with a main character called jack who likes fruit as movies with a close similarity.\n\nthis is correct in one sense; they are both movies and very similar when compared to a cricket bat or a vanilla yoghurt.\n\non the other hand, if you are recommending a movie to pass away a rainy afternoon, a fairy tale for children is very different to a horror film.\n\n== incorporating graph features\n\ngraph features can enrich vector-backed semantic search by providing structural and relational context to data.\n\nby leveraging the connections in graphs, semantic search can draw upon relationships and hierarchies between entities, enhancing the depth and relevance of search results.", "by leveraging the connections in graphs, semantic search can draw upon relationships and hierarchies between entities, enhancing the depth and relevance of search results.\n\nwhile vectors capture semantic nuances, adding graph structures allows for a more holistic understanding of data, considering its inherent meaning and position in a broader knowledge network.\n\n//todo - do we want to embed this video? i think it will age quickly\n\n// this topic is out of the scope of this module, but for more information, watch link:https://www.youtube.com/watch?v=brd09ndyjns[going meta - ep 21: vector-based semantic search and graph-based semantic search^], in which dr jesus barrasa and alexander erdl explore the differences between vector-based semantic search and graph-based semantic search.\n\n// image::images/jesus-barrassa.png[dr jesus barrasa]\n// _dr jesus barrasa_\n\n== using feedback\n\na more straightforward approach may be to use user feedback to gradually re-rank and curate the content returned by a vector index search.\n\ngraphacademy has a chatbot that uses this approach to improve the quality of its responses.\n\n[note]\n.the graphacademy chatbot\n====\nyou can access the graphacademy chatbot by clicking on the chat icon image:images/chat-icon.png[chat icon] in the bottom right corner of the graphacademy website.\n====\n\nwhen a user asks a question, the server generates an embedding of the question and uses the vector index to identify relevant content.", "when a user asks a question, the server generates an embedding of the question and uses the vector index to identify relevant content.\n\nthis approach works well in most cases, but now and again, the index fails to return relevant content, in which case the server instructs the llm to respond to the user with an apology.\n\ngraphacademy stores questions, responses, and the user's feedback in the database. over time, a better picture of which documents do or do not answer specific queries emerges. \n\nthe chatbot can use this context to improve future responses. for example, when a user asks a question, the chatbot can compare it to previous questions and exclude any suggested documents where the answer was previously unhelpful.\n\n[tip]\n.want to know more?\n====\nthe article link:https://medium.com/neo4j/building-an-educational-chatbot-for-graphacademy-with-neo4j-f707c4ce311b[building an educational chatbot for graphacademy with neo4j using llms and vector search^] describes in more detail how we ingested neo4j documentation and graphacademy lessons, using embeddings of the content to populate a vector index.\n\nimage::images/chatbot-data-model.png[the graphacademy chatbot data model]\n====\n\n\nread::continue[]\n\n[.summary]\n\n== module summary\n\nin this module, you have learned how to implement vector search in neo4j.", "read::continue[]\n\n[.summary]\n\n== module summary\n\nin this module, you have learned how to implement vector search in neo4j.\n\nyou have learned how to create a vector index using the `db.index.vector.createnodeindex()` procedure, set vector properties using the `db.create.setvectorproperty()` procedure, and query the vector index using the `db.index.vector.querynodes()` procedure.\n\nyou also explored the benefits and potential drawbacks of vector-based semantic search.\n\nin the next module, you will get hands-on with langchain, a framework designed to simplify the creation of applications using large language models.", "= an introduction to langchain\n:order: 1\n:type: lesson\n\nthis lesson will teach you about langchain, an open-source framework for building ai applications.\n\n== what is langchain?\n\nlink:https://langchain.com[langchain^] is designed to accelerate the development of llm applications.\n\nlangchain enables software developers to build llm applications quickly, integrating with external components and data sources.\n\ndevelopers can build langchain applications with link:https://python.langchain.com/[python^] or link:https://js.langchain.com/[javascript/typescript^].\n\nlangchain supports multiple llms and allows you to swap one for another with a single parameter change.\n\nmeaning you can quickly test multiple llms for suitability and utilize different models for different use cases.\n\nlangchain provides out-of-the-box integrations with apis and databases including link:https://python.langchain.com/docs/integrations/providers/neo4j[neo4j^].\n\nlangchain's flexibility allows you to test different llm providers and models with minimal code changes.\n\n== how does it work?\n\nlangchain applications bridge users and llms, communicating back and forth with the llm through **chains**.\n\nthe key components of a langchain application are:\n\n* **model interaction (model i/o)**: components that manage the interaction with the language model, overseeing tasks like feeding inputs and extracting outputs.", "* **model interaction (model i/o)**: components that manage the interaction with the language model, overseeing tasks like feeding inputs and extracting outputs.\n\n* **data connection and retrieval:** retrieval components can access, transform, and store data, allowing for efficient queries and retrieval.\n\n* **chains:** chains are reusable components that determine the best way to fulfill an instruction based on a _prompt_.\n\n* **agents:** agents orchestrate commands directed at llms and other tools, enabling them to perform specific tasks or solve designated problems.\n\n* **memory:** allow applications to retain context, for example, remembering the previous messages in a conversation.\n\n[%collapsible]\n.click to reveal an example langchain application\n====\nthis example program uses langchain to build a chatbot that answers questions about neo4j cypher queries.\n\nthe program interacts with an openai llm, uses a prompt template to instruct the llm on _how to act_, and uses a memory component to retain context.\n\nafter completing this module, you will understand what this program does and how it works.\n\n[source, python]\n----\ninclude::code/example_applcation.py[][]\n----\n====\n\nin the next lesson, you will set up your development environment and use langchain to query an llm.\n\n== check your understanding\n\ninclude::questions/1-languages.adoc[leveloffset=+1]\n\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned about langchain, an open-source framework for building ai applications.", "include::questions/1-languages.adoc[leveloffset=+1]\n\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned about langchain, an open-source framework for building ai applications.\n\nin the next lesson, you will learn how to set up your development environment and use langchain to query an llm.", "= initialising the llm\n:order: 2\n:type: lesson\n\nin this lesson, you will:\n\n* install the langchain python package\n* initialize an llm\n* get a response from the llm using a *prompt*\n\n[important]\n.python v3.12+\nas of writing, link:https://github.com/langchain-ai/langchain/issues/11479[langchain doesn't support python v3.12 or above^]. you can download python v3.11 from link:https://www.python.org/downloads/[python.org/downloads^].\n\n== choosing your llm\n\nlangchain supports multiple llm providers (link:https://openai.com/[openai^], link:https://cohere.com/[cohere^], link:https://ollama.ai/[ollama^] and more). the quality and cost vary. llms are also trained for different purposes, so it is worth experimenting with models and prompts. depending on your use case, different llms may return better results.\n\nthis course includes instructions for using link:https://openai.com/[openai^], but the same principles apply to all llms.\n\n[note]\n.using openai\nif you wish to use openai and follow this course's practical activities, you must create an account and set up billing.\n\n== setup\n\n=== installing langchain\n\nto use langchain, you must install the `langchain` package and its dependencies using `pip`:\n\n[source,sh]\n.install langchain\npip install langchain", "== setup\n\n=== installing langchain\n\nto use langchain, you must install the `langchain` package and its dependencies using `pip`:\n\n[source,sh]\n.install langchain\npip install langchain\n\n[tip]\n.virtual environment\n====\nyou may find it helpful to create a python virtual environment using a tool like link:https://virtualenv.pypa.io/en/latest/[virtualenv^]. using a virtual environment allows you to install packages without affecting your system python installation.\n====\n\n=== installing openai\n\nyou will need to setup openai at link:https://platform.openai.com[platform.openai.com], including:\n\n* creating an account\n* creating an api key\n* setting up billing\n\nyou can install the `openai` and `langchain-openai` python packages using `pip`:\n\n[source,sh]\n.install openai sdk\npip install openai langchain-openai\n\n== create a langchain application\n\ncreate a new python program and copy this code into it.\n\n[source,python]\n----\nfrom langchain_openai import openai\n\nllm = openai(openai_api_key=\"sk-...\")\n\nresponse = llm.invoke(\"what is neo4j?\")\n\nprint(response)\n----\n\n[important]\n.openai api key\nremember to include your openai api key in the `openai_api_key` parameter.\n\nreview the program and note the following:\n\n* that `openai` is used as the llm\n* you can pass a question to the `llm.invoke` and get a response\n\nrunning the program should produce a response from the llm similar to:", "* that `openai` is used as the llm\n* you can pass a question to the `llm.invoke` and get a response\n\nrunning the program should produce a response from the llm similar to:\n\n    neo4j is an open-source, nosql graph database management system developed by neo4j, inc. it is designed to store and manage data in a graph-like structure using nodes, relationships, and properties. neo4j is used for a wide variety of use cases including real-time data analytics, fraud detection, recommendation engines, and network and it operations.\n\ntry modifying the program to ask a different question.\n\n== prompts\n\nprompt templates allow you to create reusable instructions or questions. you can use them to create more complex or structured input for the llm.\n\nbelow is an example of a prompt template:\n\n[source, python]\n----\n\"\"\"\nyou are a cockney fruit and vegetable seller.\nyour role is to assist your customer with their fruit and vegetable needs.\nrespond using cockney rhyming slang.\n\ntell me about the following fruit: {fruit}\n\"\"\"\n----\n\nthis prompt template would give context to the llm and instruct it to respond as a cockney fruit and vegetable seller.\n\nyou can define parameters within the template using braces `{}` e.g. `{fruit}`. these parameters will be replaced with values when the prompt is formatted.\n\nmodify your program to use the prompt template:\n\n[source,python]\n----\nfrom langchain.prompts import prompttemplate", "modify your program to use the prompt template:\n\n[source,python]\n----\nfrom langchain.prompts import prompttemplate\n\ntemplate = prompttemplate(template=\"\"\"\nyou are a cockney fruit and vegetable seller.\nyour role is to assist your customer with their fruit and vegetable needs.\nrespond using cockney rhyming slang.\n\ntell me about the following fruit: {fruit}\n\"\"\", input_variables=[\"fruit\"])\n----\n\ncall the llm, passing the formatted prompt template as the input:\n\n[source,python]\n----\nresponse = llm.invoke(template.format(fruit=\"apple\"))\n\nprint(response)\n----\n\nyou use the `format` method to pass the parameters to the prompt e.g. `fruit=\"apple\"`. the input variables will be validated when the prompt is formatted, and a `keyerror` will be raised if any variables are missing from the input.\n\nthe prompt will be formatted as follows:\n\n    you are a cockney fruit and vegetable seller.\n    your role is to assist your customer with their fruit and vegetable needs\n    respond using cockney rhyming slang.\n    tell me about the following fruit: apple\n\nwhen running the program, you should see a response similar to:\n\n    well, apples is a right corker - they come in all shapes and sizes from granny smiths to royal galas. got 'em right 'ere, two a penny - come and grab a pick of the barrel!\n\n[note]\n.differing results\nif you run the program multiple times, you will notice you get different responses because the llm is generating the answer each time.", "[note]\n.differing results\nif you run the program multiple times, you will notice you get different responses because the llm is generating the answer each time.\n\nbefore moving on to the next lesson, try creating a prompt template and using it to get a response from the llm.\n\n[tip]\n.creating prompttemplates\nyou can create a prompt from a string by calling the `prompttemplate.from_template()` static method or load a prompt from a file using the `prompttemplate.from_file()` static method.\n\n== configuring the llm\n\nwhen you create the llm, you can configure it with parameters such as the `temperature` and `model`.\n\n[source,python]\n----\nllm = openai(\n    openai_api_key=\"sk-...\",\n    model=\"gpt-3.5-turbo-instruct\",\n    temperature=0\n)\n----\n\nwhen selecting a model, it is worth considering the quality of the output and the cost per token. there are several link:https://platform.openai.com/docs/models/overview[openai models^] available, each with different characteristics.\n\nas you learned in the first module, all prompts have a `temperature`. the temperature, between `0.0` and `1.0`, affects the randomness or creativeness of the response.\n\nnote how the code above uses the \"gpt-3.5-turbo-instruct\" model with a temperature of `0.0`. typically, this will produce a good response, as grounded in fact as possible.\n\n== check your understanding\n\ninclude::questions/1-prompts.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary", "== check your understanding\n\ninclude::questions/1-prompts.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned how to communicate with an llm with text and prompt templates.\n\nin the next lesson, you will learn all about langchain **chains**.", "= chains\n:order: 3\n:type: lesson\n\nin this lesson, you will learn about chains and how to use them to create reusable components.\n\nchains allows you to combine language models with different data sources and third-party apis.\n\n== using llmchain\n\nthe simplest chain is an `llmchain`. an `llmchain` combines a prompt template with an llm and returns a response.\n\npreviously, you created a program that used a prompt template and an llm to generate a response about fruit.\n\n[%collapsible]\n.click to reveal the code for the program.\n====\n[source,python]\n----\ninclude::../2-initialising-the-llm/code/llm_prompt.py[]\n----\n====\n\nyou can combine this program into a chain and create a reusable component.\n\n[source,python]\n----\ninclude::code/llm_chain.py[]\n----\n\nnote how the `llm_chain.invoke` method accepts the template parameters as a dictionary.\n\n[source,python]\n----\nresponse = llm_chain.invoke({\"fruit\": \"apple\"})\n----\n\nthe `response` is a dictionary containing the template parameters and a `text` key containing the response from the llm.\n\n    {'fruit': 'apple', 'text': 'well, mate, apples and pears are what i sell...'}\n\n== output parsers\n\nyou can specify that a chain uses a specific link:https://python.langchain.com/docs/modules/model_io/output_parsers/[output parser^] to parse the output of the llm.\n\nsetting the `output_parser` parameter to `stroutputparser` on the `llmchain` would ensure the response is a string.\n\n[source,python]\n----\nfrom langchain.schema import stroutputparser", "setting the `output_parser` parameter to `stroutputparser` on the `llmchain` would ensure the response is a string.\n\n[source,python]\n----\nfrom langchain.schema import stroutputparser\n\nllm_chain = llmchain(\n    llm=llm,\n    prompt=template,\n    output_parser=stroutputparser()\n)\n----\n\nyou can change the prompt to instruct the llm to return a specific output type. for example, return json by specifying `output json` and give a format in the prompt:\n\n[source,python]\n----\ntemplate = prompttemplate.from_template(\"\"\"\nyou are a cockney fruit and vegetable seller.\nyour role is to assist your customer with their fruit and vegetable needs.\nrespond using cockney rhyming slang.\n\noutput json as {{\"description\": \"your response here\"}}\n\ntell me about the following fruit: {fruit}\n\"\"\")\n----\n\nyou can ensure langchain parses the response as json by specifying `simplejsonoutputparser` as the `output_parser`:\n\n[source,python]\n----\nfrom langchain.output_parsers.json import simplejsonoutputparser\n\nllm_chain = llmchain(\n    llm=llm,\n    prompt=template,\n    output_parser=simplejsonoutputparser()\n)\n----\n\nthe benefits of using chains are:\n\n* **modularity**: langchain provides many modules that can be used to build language model applications. these modules can be used as stand-alones in simple applications and they can be combined for more complex use cases.", "* **customizability**: most langchain applications allow you to configure the llm and/or the prompt used, so knowing how to take advantage of this will be a big enabler.\n\n* **ease** of use: the components are designed to be easy to use, regardless of whether you are using the rest of the langchain framework or not.\n\n* **standard** interface: langchain provides a standard interface for chains, enabling developers to create sequences of calls that go beyond a single llm call.\n\n== check your understanding\n\ninclude::questions/1-chains.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned about llm chains and how they can group a prompt, llm, and output parser.\n\nin the next lesson, you will learn about chat models.", "= chat models\n:order: 4\n:type: lesson\n\nin the previous lesson, you learned how to communicate with the openai llm using langchain.\n\nthe communication was simple, you provided a prompt and got a response.\n\nin this lesson, you will learn how to use a chat model to _have a conversation_ with the llm.\n\n== chat models vs language models\n\nuntil now, you have been using a language model to communicate with the llm. a language model predicts the next word in a sequence of words. chat models are designed to have conversations - they accept a list of messages and return a conversational response.\n\nchat models typically support different types of messages:\n\n* system - system messages instruct the llm on how to act on human messages\n* human - human messages are messages sent from the user\n* ai - responses from the ai are called ai responses\n\n== create a chat model\n\nyou are going to create an application that uses a chat model.\n\nthe application will:\n\n* use a system message to provide instructions\n* use a human message to ask a question\n* receive an ai response to the question\n\ncreate a new python program, import the required langchain modules and instantiate the chat model.\n\n[important]\n.openai api key\nremember to update the api key with your own.\n\n[source,python]\n----\nfrom langchain_openai import chatopenai\nfrom langchain_core.messages import humanmessage, systemmessage  \n\nchat_llm = chatopenai(\n    openai_api_key=\"sk-...\"\n)\n----", "[source,python]\n----\nfrom langchain_openai import chatopenai\nfrom langchain_core.messages import humanmessage, systemmessage  \n\nchat_llm = chatopenai(\n    openai_api_key=\"sk-...\"\n)\n----\n\ncreate a system message to provide instructions to the chat model using the link:https://api.python.langchain.com/en/latest/messages/langchain_core.messages.system.systemmessage.html[`systemmessage`^] class.\n\n[source,python]\n----\ninstructions = systemmessage(content=\"\"\"\nyou are a surfer dude, having a conversation about the surf conditions on the beach.\nrespond using surfer slang.\n\"\"\")\n----\n\ncreate a link:https://api.python.langchain.com/en/latest/messages/langchain_core.messages.human.humanmessage.html[`humanmessage`^] object to ask a question.\n\n[source,python]\nquestion = humanmessage(content=\"what is the weather like?\")\n\nyou can now call the chat model passing a list of messages. in this example, pass the system message with the instructions and the human message with the question.\n\n[source,python]\n----\nresponse = chat_llm.invoke([\n    instructions,\n    question\n])\n\nprint(response.content)\n----\n\n[%collapsible]\n.reveal the complete code\n====\n[source,python]\n----\ninclude::code/chat-model.py[]\n----\n====\n\nthe `response` is an link:https://api.python.langchain.com/en/latest/messages/langchain_core.messages.ai.aimessage.html[`aimessage`^] object.", "the `response` is an link:https://api.python.langchain.com/en/latest/messages/langchain_core.messages.ai.aimessage.html[`aimessage`^] object.\n\n[source,python]\naimessage(content=\"dude, the weather is totally gnarly! it's sunny with some epic offshore winds. perfect conditions for shredding some sick waves!\", additional_kwargs={}, example=false)\n\n=== wrapping in a chain\n\nyou can create a reusable chat model chain using what you have learned about prompts and chains.\n\nrather than passing a list of messages to the chat model, you can create a prompt that gives context to the conversation and then pass the question to the chat model.\n\nreview this program and identify the following:\n\n* the prompt provides the instructions to the llm.\n* the chain is created using the chat model and the prompt.\n* the question is passed to the chat model as a parameter of the `invoke` method.\n\n[source,python]\n----\ninclude::code/chat-model-chain.py[]\n----\n\ncreating a chain is the first step to creating a more sophisticated chat model. you can use chains to combine different elements into one call and support more complex features.\n\n=== giving context\n\npreviously, you learned about grounding and how it can provide context to the llm and avoid _hallucination_.\n\ncurrently the chat model is not grounded; it is unaware of surf conditions on the beach. it responds based on the question and the llms training data (which could be months or years out of date).", "currently the chat model is not grounded; it is unaware of surf conditions on the beach. it responds based on the question and the llms training data (which could be months or years out of date).\n\nyou can ground the chat model by providing information about the surf conditions on the beach.\n\nreview this example where the chat model can access current beach conditions (`current_weather`) as a variable (`context`) in the prompt.\n\n[source,python]\n----\ninclude::code/chat-model-context.py[]\n----\n\nrun the program and predict what the response will be.\n\n[%collapsible]\n.click to reveal the response\n====\nbelow is a typical response. the llm has used the context passed in the prompt to provide a more accurate response.\n\n    {\n        'context': {\n            \"surf\": [\n                {\"beach\": \"fistral\", \"conditions\": \"6ft waves and offshore winds\"},\n                {\"beach\": \"polzeath\", \"conditions\": \"flat and calm\"},\n                {\"beach\": \"watergate bay\", \"conditions\": \"3ft waves and onshore winds\"}\n            ]},\n        'question': 'what is the weather like on watergate bay?',\n        'text': \"dude, the surf at watergate bay is pumping! we got some sick 3ft waves rolling in, but unfortunately, we got some onshore winds messing with the lineup. but hey, it's all good, still plenty of stoke to be had out there!\"\n    }\n====\n\ninvestigate what happens when you change the context by adding additional beach conditions.", "investigate what happens when you change the context by adding additional beach conditions.\n\nproviding context is one aspect of retrieval augmented generation (rag). in this program, you _manually_ gave the model context; however, you could have retrieved real-time information from an api or database.\n\n== check your understanding\n\ninclude::questions/1-message-types.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned that chat models are designed for conversations and how to add additional context.\n\nin the next lesson, you will learn how to give your chat model a memory so it can retain information between questions.", "= giving a chat model memory\n:order: 5\n:type: lesson\n\nfor a chat model to be helpful, it needs to remember what messages have been sent and received.\n\nwithout the ability to _remember_ the chat model will not be able to act according to the context of the conversation.\n\nfor example, without a memory the conversation may go in circles:\n\n    [user] hi, my name is martin\n\n    [chat model] hi, nice to meet you martin\n\n    [user] do you have a name?\n\n    [chat model] i am the chat model. nice to meet you. what is your name?\n\n== conversation memory\n\nin the previous lesson, you created a chat model that responds to user's questions about surf conditions.\n\n[%collapsible]\n.reveal the code\n====\n[source,python]\n----\ninclude::../3-chat-models/code/chat-model-context.py[]\n----\n====\n\nin this lesson, you will add a memory to this program.\n\nlangchain supports several link:https://python.langchain.com/docs/modules/memory/[memory types^], which support different scenarios.\n\nyou will use the link:https://python.langchain.com/docs/modules/memory/types/buffer[conversation buffer] memory type to store the conversation history between you and the llm.\n\nas each call to the llm is stateless, you need to include the chat history in every call to the llm. you can modify the prompt template to include the chat history in a variable.\n\n[source, python]\n----\nprompt = prompttemplate(template=\"\"\"you are a surfer dude, having a conversation about the surf conditions on the beach.\nrespond using surfer slang.", "[source, python]\n----\nprompt = prompttemplate(template=\"\"\"you are a surfer dude, having a conversation about the surf conditions on the beach.\nrespond using surfer slang.\n\nchat history: {chat_history}\ncontext: {context}\nquestion: {question}\n\"\"\", input_variables=[\"chat_history\", \"context\", \"question\"])\n----\n\nthe `chat_history` variable will contain the conversation history.\n\nyou can now create the `conversationbuffermemory` and pass it to the `llmchain`:\n\n[source, python]\n----\nfrom langchain.chains.conversation.memory import conversationbuffermemory\n\nmemory = conversationbuffermemory(memory_key=\"chat_history\", input_key=\"question\", return_messages=true)\n\nchat_chain = llmchain(llm=chat_llm, prompt=prompt, memory=memory)\n----\n\nthere are three parameters to the `conversationbuffermemory`:\n\n* `memory_key` - is the variable in the prompt that will hold the conversation history\n* `input_key` - is the variable in the prompt that will hold the user's question to the chat model\n* `return_messages` - when true, the conversation history will be returned as a list\n\nwhen you create the `llmchain`, the `memory` parameter should be set to the `conversationbuffermemory` instance.\n\nwhen you ask the chat model multiple questions, the llm will use the context from the previous questions when responding.\n\n[source, python]\n----\nresponse = chat_chain.invoke({\n    \"context\": current_weather,\n    \"question\": \"hi, i am at watergate bay. what is the surf like?\"\n})\nprint(response[\"text\"])", "[source, python]\n----\nresponse = chat_chain.invoke({\n    \"context\": current_weather,\n    \"question\": \"hi, i am at watergate bay. what is the surf like?\"\n})\nprint(response[\"text\"])\n\nresponse = chat_chain.invoke({\n    \"context\": current_weather,\n    \"question\": \"where i am?\"\n})\nprint(response[\"text\"])\n----\n\n    [user] hi, i am at watergate bay. what is the surf like?\n\n    [chat model] dude, stoked you're at watergate bay! the surf is lookin' pretty chill, about 3ft waves rollin' in. but watch out for those onshore winds, they might mess with your flow.\n\n    [user] where i am?\n\n    [chat model] you're at watergate bay, dude!\n\n[tip]\n.see the conversation history\n====\nyou can set the `llmchain` `verbose` parameter to `true` to see the conversation history in the console.\n[source, python]\n----\nchat_chain = llmchain(llm=chat_llm, prompt=prompt, memory=memory, verbose=true)\n----\n====\n\ntry creating a simple loop and ask the chat model a few questions:\n\n[source, python]\n----\nwhile true:\n    question = input(\"> \")\n    response = chat_chain.invoke({\n        \"context\": current_weather,\n        \"question\": question\n        })\n\n    print(response[\"text\"])\n----\n\n[%collapsible]\n.click to reveal the complete code.\n====\n[source,python]\n----\ninclude::code/chat-model-memory.py[]\n----\n====\n\n== check your understanding\n\ninclude::questions/1-state.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary", "== check your understanding\n\ninclude::questions/1-state.adoc[leveloffset=+1]\n\n[.summary]\n== lesson summary\n\nin this lesson, you learned how to use the `conversationbuffermemory` to store the conversation history between you and the llm.\n\nin the next lesson, you will learn how to create an agent to give an llm access to different tools and data sources.", "= agents\n:order: 6\n:type: lesson\n\nin this lesson, you will learn how to create an link:https://python.langchain.com/docs/modules/agents[agent^].\n\nagents wrap a model and give it access to a set of _tools_. these tools may access additional data sources, apis, or functionality. the model is used to determine which of the tools to use to complete a task.\n\nthe agent you will create will be able to chat about movies and search youtube for movie trailers.\n\n== tools\n\na tool is a specific abstraction around a function that makes it easy for a language model to interact with it. link:https://python.langchain.com/docs/integrations/tools[langchain provides several tools^] out of the box, and you can create tools to extend the functionality of your agents.\n\ntools can be grouped into link:https://python.langchain.com/docs/integrations/toolkits/[toolkits^] to solve a particular problem. for example, a toolkit that gets youtube information - videos, thumbnails, transcripts, views, etc.\n\nyou will use the link:https://python.langchain.com/docs/integrations/tools/youtube/[youtubesearchtool^] to search youtube for movie trailers.\n\n== movie trailer agent\n\nreview the program below, before running it.\n\n[source,python]\n----\ninclude::code/chat-agent.py[]\n----\n\n[%collapsible]\n.click here to see a typical output from this program\n====\n    [user] find a movie where aliens land on earth.", "[source,python]\n----\ninclude::code/chat-agent.py[]\n----\n\n[%collapsible]\n.click here to see a typical output from this program\n====\n    [user] find a movie where aliens land on earth.\n\n    [chat model] sure, i can help you with that. one movie i would recommend where aliens land on earth is \"arrival\" (2016). it's a science fiction film directed by denis villeneuve. the story follows a linguist who is recruited by the military to help communicate with an alien species that has landed on earth. it's a thought-provoking and visually stunning movie that explores themes of communication, time, and the human experience. i hope you enjoy it!\n====\n\nbased on your understanding from previous lessons, you should be able to identify the following:\n\n. a chat model is being used to have a conversation about movies\n. the prompt which sets the context for the llm and the input variables\n. that memory is used to store the conversation history\n. a chain is created to link the chat model, prompt, and memory together\n\nin addition to the above, the following is new:", "in addition to the above, the following is new:\n\n. a tool is created using the chain:\n+\n[source,python]\n----\ntools = [\n    tool.from_function(\n        name=\"movie chat\",\n        description=\"for when you need to chat about movies. the question will be a string. return a string.\",\n        func=chat_chain.run,\n        return_direct=true\n    )\n]\n----\n. an agent is created that uses the tool:\n+\n[source, python]\n----\nagent_prompt = hub.pull(\"hwchase17/react-chat\")\nagent = create_react_agent(llm, tools, agent_prompt)\nagent_executor = agentexecutor(agent=agent, tools=tools, memory=memory)\n----\n\n### creating tools\n\ntools are interfaces that an agent can interact with. you can link:https://python.langchain.com/docs/modules/agents/tools/custom_tools[create custom tools^] able to perform any functionality you want.\n\nin this example, the tool is created from a function. the function is the `chat_chain.run` method.\n\n[source, python]\n----\ntools = [\n    tool.from_function(\n        name=\"movie chat\",\n        description=\"for when you need to chat about movies. the question will be a string. return a string.\",\n        func=chat_chain.run,\n        return_direct=true\n    )\n]\n----\n\nthe `name` and `description` help the llm select which tool to use when presented with a question. the `func` parameter is the function that will be called when the tool is selected. the `return_direct` flag indicates that the tool will return the result directly.", "agents support multiple tools, so you pass them to the agent as a list (`tools`).\n\n### initializing an agent\n\nthe following code creates the agent:\n\n[source, python]\n----\nagent_prompt = hub.pull(\"hwchase17/react-chat\")\nagent = create_react_agent(llm, tools, agent_prompt)\nagent_executor = agentexecutor(agent=agent, tools=tools, memory=memory)\n----\n\nthere are different link:https://python.langchain.com/docs/modules/agents/agent_types/[types of agents^] that you can create. this example creates a _react_ - reasoning and acting) agent type.\n\nan agent requires a prompt. you could create a prompt, but in this example, the program pulls a pre-existing prompt from the link:https://smith.langchain.com/hub/[langsmith hub^].\n\nthe link:https://smith.langchain.com/hub/hwchase17/react-chat?organizationid=d9a804f5-9c91-5073-8980-3d7112f1cbd3[`hwcase17/react-chat`^] prompt instructs the model to provide an answer using the tools available in a specific format.\n\nthe `create_react_agent` function creates the agent and expects the following parameters:\n\n* the `llm` that will manage the interactions and decide which tool to use\n* the `tools` that the agent can use\n* the `prompt` that the agent will use\n\nthe `agentexecutor` class runs the agent. it expects the following parameters:\n\n* the `agent` to run\n* the `tools` that the agent can use\n* the `memory` which will store the conversation history", "the `agentexecutor` class runs the agent. it expects the following parameters:\n\n* the `agent` to run\n* the `tools` that the agent can use\n* the `memory` which will store the conversation history\n\n[tip]\n.agentexecutor parameters\n====\nyou may find the following additional parameters useful when initializing an agent:\n\n* `max_iterations` - the maximum number of iterations to run the llm for. this is useful in preventing the llm from running for too long or entering an infinite loop.\n* `verbose` - if `true` the agent will print out the llm output and the tool output.\n* `handle_parsing_errors` - if `true` the agent will handle parsing errors and return a message to the user.\n\n[source, python]\n----\nagent_executor = agentexecutor(\n    agent=agent,\n    tools=tools,\n    memory=memory,\n    max_interations=3,\n    verbose=true,\n    handle_parse_errors=true\n)\n----\n====\n\n=== multiple tools\n\na key advantage of using an agent is that they can use multiple tools. access to multiple tools allows you to create agents that can perform several specific tasks.\n\nyou can extend this example to allow it to search youtube for movie trailers by adding the link:https://python.langchain.com/docs/integrations/tools/youtube/[youtubesearchtool^] to the `tools` list.\n\nfirsly, you will need to install the link:https://pypi.org/project/youtube-search/[`youtube-search`^] package.\n\n[source, bash]\n----\npip install youtube-search\n----\n\nimport the `youtubesearchtool` and create a new tool.", "[source, bash]\n----\npip install youtube-search\n----\n\nimport the `youtubesearchtool` and create a new tool.\n\n[source, python]\n----\nfrom langchain_community.tools import youtubesearchtool\n\nyoutube = youtubesearchtool()\n\ntools = [\n    tool.from_function(\n        name=\"movie chat\",\n        description=\"for when you need to chat about movies. the question will be a string. return a string.\",\n        func=chat_chain.run,\n        return_direct=true\n    ),\n    tool.from_function(\n        name=\"movie trailer search\",\n        description=\"use when needing to find a movie trailer. the question will include the word 'trailer'. return a link to a youtube video.\",\n        func=youtube.run,\n        return_direct=true\n    )\n]\n----\n\n[%collapsible]\n.click here to reveal the complete program\n====\n[source, python]\n----\ninclude::code/movie-trailer-agent.py[]\n----\n====\n\nthe model will then use the `name` and `description` for each tool to decide which tool to use.\n\nwhen prompted to find a movie trailer, the model should use the `youtubesearchtool` tool.\n\n    [user] find the movie trailer for the matrix.\n\n    [agent] ['https://www.youtube.com/watch?v=vkqi3bba1y8&pp=yguutwf0cml4ig1vdmllihryywlszxi%3d', 'https://www.youtube.com/watch?v=9ix7tugvyio&pp=yguutwf0cml4ig1vdmllihryywlszxi%3d']\n\nhowever, when asked about movies, genres or plots, the model will use the `chat_chain` tool.\n\n    [user] find a movie about the meaning of life", "however, when asked about movies, genres or plots, the model will use the `chat_chain` tool.\n\n    [user] find a movie about the meaning of life\n\n    [agent] certainly! one movie that explores the meaning of life is \"the tree of life\" directed by terrence malick. it follows the journey of a young boy as he grows up in the 1950s and reflects on his experiences and the meaning of existence. it's a visually stunning and thought-provoking film that delves into existential questions.\n\nas the agent also uses the conversation memory you can refer back to the previous questions, such as finding a trailer for a movie it has recommended:\n\n    [user] can you find the trailer\n\n    [agent] ['https://www.youtube.com/watch?v=rraz1ylh8ny&pp=yguevghlifryzwugb2ygtglmzsbtb3zpzsb0cmfpbgvy', 'https://www.youtube.com/watch?v=okqqboxuvye&pp=yguevghlifryzwugb2ygtglmzsbtb3zpzsb0cmfpbgvy']\n\nagents and tools allow you to create more adaptable and flexible models to perform multiple tasks.\n\n== check your understanding\n\ninclude::questions/1-agents.adoc[leveloffset=+1]\n\n[.summary]\n== summary\n\nin this lesson, you learned how to create an agent to use multiple tools.\n\nin the next lesson, you will learn how to use langchain to connect to a neo4j database.", "= connecting to neo4j\n:order: 7\n:type: lesson\n:disable-cache: true\n\nlangchain includes functionality to integrate directly with neo4j, including allowing you to run cypher statements, query vector indexes and use neo4j as a vector store.\n\nin this lesson, you will learn how to connect to a neo4j instance and run cypher statement.\n\n== connecting to a neo4j instance\n\nyou must install the `neo4j` python package to connect to a neo4j database.\n\n[source,shell]\n----\npip install neo4j\n----\n\nthe following code will connect to a neo4j database and run a simple query.\n\n[source,python]\n----\ninclude::code/connect-to-neo4j.py[]\n----\n\nyou can connect to the neo4j sandbox created for you when you joined the course.\n\nupdate the code above to use the `url`, `username` and `password` of your neo4j sandbox.\n\nconnection url:: [copy]#bolt://{sandbox_ip}:{sandbox_boltport}#\nusername:: [copy]#{sandbox_username}#\npassword:: [copy]#{sandbox_password}#\n\nrun the query - you should see data about the movie toy story.\n\nthe `neo4jgraph` class is a wrapper to the link:https://neo4j.com/docs/python-manual/current/[neo4j python driver^]. it simplifies connecting to neo4j and integrating with the langchain framework.\n\n== schema\n\nwhen you connect to the neo4j database, the object loads the database schema into memory - this enables langchain to access the schema information without having to query the database.\n\nyou can access the schema information using the `schema` property.", "you can access the schema information using the `schema` property.\n\n[source,python]\n----\nprint(graph.schema)\n----", "[%collapsible]\n.view schema\n====\n    node properties are the following:\n    [{'properties': [{'property': 'url', 'type': 'string'}, {'property': 'runtime', 'type': 'integer'}, {'property': 'revenue', 'type': 'integer'}, {'property': 'budget', 'type': 'integer'}, {'property': 'imdbrating', 'type': 'float'}, {'property': 'released', 'type': 'string'}, {'property': 'countries', 'type': 'list'}, {'property': 'languages', 'type': 'list'}, {'property': 'plot', 'type': 'string'}, {'property': 'imdbvotes', 'type': 'integer'}, {'property': 'imdbid', 'type': 'string'}, {'property': 'year', 'type': 'integer'}, {'property': 'poster', 'type': 'string'}, {'property': 'movieid', 'type': 'string'}, {'property': 'tmdbid', 'type': 'string'}, {'property': 'title', 'type': 'string'}], 'labels': 'movie'}, {'properties': [{'property': 'name', 'type': 'string'}], 'labels': 'genre'}, {'properties': [{'property': 'userid', 'type': 'string'}, {'property': 'name', 'type': 'string'}], 'labels': 'user'}, {'properties': [{'property': 'url', 'type': 'string'}, {'property': 'name', 'type': 'string'}, {'property': 'tmdbid', 'type': 'string'}, {'property': 'bornin', 'type': 'string'}, {'property': 'bio', 'type': 'string'}, {'property': 'died', 'type': 'date'}, {'property': 'born', 'type': 'date'}, {'property': 'imdbid', 'type': 'string'}, {'property': 'poster', 'type': 'string'}], 'labels': 'actor'}, {'properties': [{'property': 'url', 'type': 'string'}, {'property': 'bornin', 'type': 'string'}, {'property': 'born', 'type': 'date'}, {'property': 'died', 'type': 'date'}, {'property': 'tmdbid', 'type': 'string'}, {'property': 'imdbid', 'type': 'string'}, {'property': 'name', 'type': 'string'}, {'property': 'poster', 'type': 'string'}, {'property': 'bio', 'type': 'string'}], 'labels': 'director'}, {'properties': [{'property': 'url', 'type': 'string'}, {'property': 'bornin', 'type': 'string'}, {'property': 'bio', 'type': 'string'}, {'property': 'died', 'type': 'date'}, {'property': 'born', 'type': 'date'}, {'property': 'imdbid', 'type': 'string'}, {'property': 'name', 'type': 'string'}, {'property': 'poster', 'type': 'string'}, {'property': 'tmdbid', 'type': 'string'}], 'labels': 'person'}]\n    relationship properties are the following:\n    [{'type': 'rated', 'properties': [{'property': 'rating', 'type': 'float'}, {'property': 'timestamp', 'type': 'integer'}]}, {'type': 'acted_in', 'properties': [{'property': 'role', 'type': 'string'}]}, {'type': 'directed', 'properties': [{'property': 'role', 'type': 'string'}]}]\n    the relationships are the following:\n    ['(:movie)-[:in_genre]->(:genre)', '(:user)-[:rated]->(:movie)', '(:actor)-[:acted_in]->(:movie)', '(:actor)-[:directed]->(:movie)', '(:director)-[:directed]->(:movie)', '(:director)-[:acted_in]->(:movie)', '(:person)-[:directed]->(:movie)', '(:person)-[:acted_in]->(:movie)']\n====", "[tip]\n.refreshing the schema\nyou can refresh the schema by calling the `graph.refresh_schema()` method.\n\n== check your understanding\n\ninclude::questions/1-neo4jgraph.adoc[leveloffset=+1]\n\n[.summary]\n== summary\n\nin this lesson, you learned how to connect to a neo4j database and run cypher statements.\n\nin the next lesson, you will learn how to use neo4j as a vector store using langchain **receivers**.", "= retrievers\n:order: 8\n:type: lesson\n:disable-cache: true\n\nlink:https://python.langchain.com/docs/modules/data_connection/retrievers/[retrievers^] are langchain chain components that allow you to retrieve documents using an unstructured query.\n\n    find a movie plot about a robot that wants to be human.\n\ndocuments are any unstructured text that you want to retrieve. a retriever often uses a vector store as its underlying data structure.\n\nretrievers are a key component for creating models that can take advantage of retrieval augmented generation (rag).\n\npreviously, you loaded embeddings and created a vector index of movie plots - in this example, the movie plots are the _documents_, and a _retriever_ could be used to give a model context.\n\nin this lesson, you will create a _retriever_ to retrieve documents from the movie plots vector index.\n\n== neo4jvector\n\nthe link:https://python.langchain.com/docs/integrations/vectorstores/neo4jvector[`neo4jvector`^] is a langchain vector store that uses a neo4j database as the underlying data structure.\n\nyou can use the `neo4jvector` to generate embeddings, store them in the database and retrieve them.\n\n=== querying a vector index\n\nreview the following code that creates a `neo4jvector` from the `movieplots` index you created.\n\n[source,python]\n----\ninclude::code/query_vector.py[]\n----\n\nyou should be able to identify the following:", "[source,python]\n----\ninclude::code/query_vector.py[]\n----\n\nyou should be able to identify the following:\n\n* that an `embedding_provider` is required. in this case, `openaiembeddings`, as this was used to originally create the embeddings. the embedding provider will be used to generate embeddings for any queries.\n* the connection details for the neo4j database (`url`, `username`, `password`).\n* the name of the neo4j index (`\"movieplots\"`).\n* the name of the node property that contains the embeddings (`\"embedding\"`).\n* the name of the node property that contains the text (`\"plot\"`).\n* the `similarity_search()` method is used to retrieve documents. the first argument is the query.\n\nto run this program you will need to:\n\n. replace the `openai_api_key` with your openai api key\n. update neo4j connection details with your sandbox connection details.\n+\n[%collapsible]\n.click to reveal your sandbox connection details\n====\nyour neo4j sandbox connection details are:\n\nconnection url:: [copy]#bolt://{sandbox_ip}:{sandbox_boltport}#\nusername:: [copy]#{sandbox_username}#\npassword:: [copy]#{sandbox_password}#\n====\n\nrun the code and review the results. try different queries and see what results you get.\n\nthe `similarity_search()` method returns a list of link:https://api.python.langchain.com/en/latest/documents/langchain_core.documents.base.document.html[`document`^] objects. the `document` object includes the properties:", "* `page_content` - the content referenced by the index, in this example the plot of the movie\n* `meta_data` - a dictionary of the `movie` node properties returned by the index\n\n[tip]\n.specify the number of documents\n====\nyou can pass an optional `k` argument to the `similarity_search()` method to specify the number of documents to return. the default is 4.\n\n[source,python]\n----\nvector.similarity_search(query, k=1)\n----\n====\n\n=== creating a new vector index\n\nthe `neo4jvector` class can also generate embeddings and vector indexes - this is useful when creating vectors programmatically or at run time.\n\nthe following code would create embeddings and a new index called `myvectorindex` in the database for `chunk` nodes with a `text` property:\n\n[source,python]\n----\ninclude::code/create_index.py[]\n----\n\n== creating a retriever chain\n\nto incorporate a retriever and neo4j vector into a langchain application, you can create a _retrieval_ chain.\n\nthe `neo4jvector` class has a `as_retriever()` method that returns a retriever.\n\nthe link:https://api.python.langchain.com/en/latest/chains/langchain.chains.retrieval_qa.base.retrievalqa.html[`retrievalqa`^] class is a chain that uses a retriever as part of its pipeline. it will use the retriever to retrieve documents and pass them to a language model.\n\nby incorporating `neo4jvector` into a `retrievalqa` chain, you can use data and vectors in neo4j in a langchain application.", "by incorporating `neo4jvector` into a `retrievalqa` chain, you can use data and vectors in neo4j in a langchain application.\n\nreview this program incorporating the `movieplots` vector index into a retrieval chain.\n\n[source,python]\n----\ninclude::code/retreiver_chain.py[]\n----\n\nwhen the program runs, the `retrievalqa` chain will use the `movie_plot_vector` retriever to retrieve documents from the `movieplots` index and pass them to the `chat_llm` language model.\n\n[tip]\n.understanding the results\n====\nit can be difficult to understand how the model generated the response and how the retriever affected it.\n\nby setting the optional `verbose` and `return_source_documents` arguments to `true` when creating the `retrievalqa` chain, you can see the source documents and the retriever's score for each document.\n\n[source, python]\n----\nplot_retriever = retrievalqa.from_llm(\n    llm=chat_llm,\n    retriever=movie_plot_vector.as_retriever(),\n    verbose=true,\n    return_source_documents=true\n)\n----\n====\n\nretrievers and vector indexes allow you to incorporate unstructured data into your langchain applications.\n\n== check your understanding\n\ninclude::questions/1-retrievers.adoc[leveloffset=+1]\n\n[.summary]\n== summary\n\nin this lesson, you learned how to incorporate neo4j vector indexes and retrievers into langchain applications.\n\nin the next optional challenge, you will add the movie plots vector retriever to the chat agent you created in the previous lesson.", "= adding the neo4j vector retriever\n:order: 9\n:type: challenge\n:optional: true\n\nin this *optional* challenge, add the movie plots vector retriever to the movie trailer agent you created previously.\n\nto complete the code you will need to update the movie trailer agent to:\n\n. create the `neo4jvector` from the `movieplots` vector index.\n. create the `retrievalqa` chain using the `neo4jvector` as the retriever.\n. update the `tools` to use the `retrievalqa` chain.\n\n[%collapsible]\n.here is the code for the movie trailer agent\n====\n[source, python]\n----\ninclude::../4-agents/code/movie-trailer-agent.py[]\n----\n====\n\n[%collapsible]\n.here is the code for the movie plots vector retriever\n====\n[source, python]\n----\ninclude::../6-retrievers/code/retreiver_chain.py[]\n----\n====\n\n[tip]\n.running a retrievalqa chain from a tool\n====\ntools expect a single `query` input and a single output key.\n\nthe `retrievalqa` chain returns multiple output keys.\n\nas a result, the agent's tool executor cannot call the `retrievalqa` chain directly e.g. using `func=retrievalqa.run`.\n\nyou could wrap the `retrievalqa` chain in a function that takes a single string input, format the results and return a single string.\n\n[source,python]\n----\n# create a function to invoke the retriever\ndef run_retriever(query):\n    results = plot_retriever.invoke({\"query\":query})\n    return str(results)", "[source,python]\n----\n# create a function to invoke the retriever\ndef run_retriever(query):\n    results = plot_retriever.invoke({\"query\":query})\n    return str(results)\n\n\n# append the tool to the tools array\ntools = [\n    # ...\n    tool.from_function(\n        ...\n        func=run_retriever,\n        ...\n    )\n]\n----\n====\n\n[%collapsible]\n.click to reveal the solution\n====\nthere is no right or wrong way to complete this challenge. here is one potential solution.\n\n[source, python]\n----\ninclude::code/retriever_agent.py[]\n----\n====\n\n== summary\n\nin this optional challenge, you added the movie plots vector retriever to the movie trailer agent you created previously.\n\nin the next module, you will learn how to use an llm to generate cypher and improve the responses of an llm.\n\nread::continue[]\n\n[.summary]\n== summary\n\nin this optional challenge, you added the movie plots vector retriever to the movie trailer agent you created previously.\n\nin the next module, you will learn how to use an llm to generate cypher and improve the responses of an llm.", "= the cypher qa chain\n:order: 1\n:type: lesson\n:disable-cache: true\n\n// https://adamcowley.co.uk/posts/abridged-neo4j-cypher-generation/\n\nlanguage models and vector indexes are good at querying unstructured data. although, as you have seen, responses are not always correct, and when data is structured, it is often easier to query it directly.\n\nllms are good at writing cypher queries when given good information, such as:\n\n* the schema of the graph\n* context about the question to be answered\n* examples of questions and appropriate cypher queries\n\nin this lesson, you will learn how to use a language model to generate cypher queries to query a neo4j graph database.\n\n== generating cypher\n\nlangchain includes the link:https://api.python.langchain.com/en/latest/_modules/langchain/chains/graph_qa/cypher.html#graphcypherqachain[`graphcypherqachain`^]chain that can interact with a neo4j graph database. it uses a language model to generate cypher queries and then uses the graph to answer the question.\n\n`graphcypherqachain` chain requires the following:\n\n* an llm (`llm`) for generating cypher queries\n* a graph database connection (`graph`) for answering the queries\n* a prompt template (`cypher_prompt`) to give the llm the schema and question\n* an appropriate question which relates to the schema and data in the graph\n\nthe program below will generate a cypher query based on the schema in the graph database and the question.\n\nreview the code and predict what will happen when you run it.", "the program below will generate a cypher query based on the schema in the graph database and the question.\n\nreview the code and predict what will happen when you run it.\n\n[source,python]\n----\ninclude::code/cypher-gen.py[]\n----\n\n[note]\nbefore running the program, you must update the `openai_api_key` and the `graph` connection details.\n\n[%collapsible]\n.click to reveal your sandbox connection details\n====\nyour neo4j sandbox connection details are:\n\nconnection url:: [copy]#bolt://{sandbox_ip}:{sandbox_boltport}#\nusername:: [copy]#{sandbox_username}#\npassword:: [copy]#{sandbox_password}#\n====\n\nwhen you run the program, you should see the cypher generated from the question and the data it returned. something similar to:\n\n    generated cypher:\n    match (a:actor)-[r:acted_in]->(m:movie {title: 'toy story'})\n    where a.name = 'tom hanks'\n    return r.role\n\n    full context:\n    [{'r.role': 'woody (voice)'}]\n\nthe llm used the database schema to generate an _appropriate_ cypher query. langchain then executed the query against the graph database, and the result returned.\n\n== breaking down the program\n\nreviewing the program, you should identify the following key points:\n\n. the program instantiates the required `llm` and `graph` objects using the appropriate api and connection details.\n+\n[source,python]\n----\nllm = chatopenai(\n    openai_api_key=\"sk-...\"\n)", ". the program instantiates the required `llm` and `graph` objects using the appropriate api and connection details.\n+\n[source,python]\n----\nllm = chatopenai(\n    openai_api_key=\"sk-...\"\n)\n\ngraph = neo4jgraph(\n    url=\"bolt://localhost:7687\",\n    username=\"neo4j\",\n    password=\"pleaseletmein\",\n)\n----\n. the `cypher_generation_template` gives the llm context. the schema and question are passed to the llm as input variables.\n+\n[source,python]\n----\ncypher_generation_template = \"\"\"\nyou are an expert neo4j developer translating user questions into cypher to answer questions about movies and provide recommendations.\nconvert the user's question based on the schema.\n\nschema: {schema}\nquestion: {question}\n\"\"\"", "schema: {schema}\nquestion: {question}\n\"\"\"\n\ncypher_generation_prompt = prompttemplate(\n    template=cypher_generation_template,\n    input_variables=[\"schema\", \"question\"],\n)\n----\n+\nthe `schema` will be automatically generated from the graph database and passed to the llm. the `question` will be the user's question.\n. the program instantiates the `graphcypherqachain` chain with the `llm`, `graph`, and prompt template (`cypher_prompt`).\n+\n[source,python]\n----\ncypher_chain = graphcypherqachain.from_llm(\n    llm,\n    graph=graph,\n    cypher_prompt=cypher_generation_prompt,\n    verbose=true\n)\n----\n+\nthe program sets the `verbose` flag to `true` so you can see the generated cypher query and response.\n. the chain runs, passing an appropriate question.\n+\n[source,python]\n----\ncypher_chain.invoke({\"query\": \"what role did tom hanks play in toy story?\"})\n----\n\nexperiment with different questions and observe the results.\n\nfor example, try:\n\n. a different context - \"what movies did meg ryan act in?\"\n. an aggregate query - \"how many movies has tom hanks directed?\"\n\n== inconsistent results\n\ninvestigate what happens when you ask the same question multiple times. observe the generated cypher query and the response.\n\n    \"what role did tom hanks play in toy story?\"\n\nyou will likely see different results each time you run the program.", "\"what role did tom hanks play in toy story?\"\n\nyou will likely see different results each time you run the program.\n\n    match (actor:actor {name: 'tom hanks'})-[:acted_in]->(movie:movie {title: 'toy story'})\n    return actor.name, movie.title, movie.year, movie.runtime, movie.plot\n\n    match (a:actor {name: 'tom hanks'})-[:acted_in]->(m:movie {title: 'toy story'})-[:acted_in]->(p:person)\n    return p.name as role\n\nthe llm doesn't return consistent results - its objective is to produce an answer, not the same response, and they may not be correct.\n\nyou will see similar problems when you ask the llm different questions.\n\n[source,python]\n----\ncypher_chain.invoke({\"query\": \"what movies has tom hanks acted in?\"})\ncypher_chain.invoke({\"query\": \"how many movies has tom hanks directed?\"})\n----\n\nin the following two lessons, you will learn how to provide additional context and instructions to the llm to generate better and more consistent results.\n\n== check your understanding\n\ninclude::questions/1-cypher-chain.adoc[leveloffset=+1]\n\n\n[.summary]\n== summary\n\nin this lesson, you learned how to use a language model to generate cypher queries.\n\nin the next lesson, you will experiment with different prompts to improve the results.", "= providing specific instructions\n:order: 2\n:type: lesson\n\nin this lesson, you will learn how to provide instructions to the llm to improve the responses to questions.\n\nyou provide instructions and context to the llm in the prompt.\n\n== following the schema\n\nin the previous lesson, you used this prompt to generate cypher statements:\n\n[source,python]\n----\ncypher_generation_template = \"\"\"\nyou are an expert neo4j developer translating user questions into cypher to answer questions about movies and provide recommendations.\nconvert the user's question based on the schema.\n\nschema: {schema}\nquestion: {question}\n\"\"\"\n----\n\nthe llm's training data included many cypher statements, but these statements were not specific to the structure of your graph database. as a result the llm may generate cypher statements that are not valid and do not conform to the schema. \n\nyou can provide specific instructions to the llm to state that the generated cypher statements should follow the schema.\n\nfor example, you could give instructions only to use the provided relationship types and properties in the schema.\n\n[source,python]\n----\ncypher_generation_template = \"\"\"\nyou are an expert neo4j developer translating user questions into cypher to answer questions about movies and provide recommendations.\nconvert the user's question based on the schema.", "instructions:\nuse only the provided relationship types and properties in the schema.\ndo not use any other relationship types or properties that are not provided.\n\nschema: {schema}\nquestion: {question}\n\"\"\"\n----\n\n[tip]\n.instructions not rules\nthere is no right or wrong way to provide instructions to the llm. the instructions are unlike traditional programming tasks where you would supply rules or definitions. you may have to experiment to find the right balance between providing too much or too little instruction.\n\nfor example, the instructions are expressed as both a positive and negative statement. you will do this. you won't do this. \n\n    use only the provided relationship types and properties in the schema.\n    do not use any other relationship types or properties that are not provided.\n\nthe results of this change may not be immediately apparent when you run the program. instructions allows you to fine-tune the llm's responses and make them more consistent.\n\n== understanding data\n\nthe llm may also need additional instructions about the data. for example, how data is formatted or how to handle missing data.\n\nif you ask the llm to generate cypher for the question:\n    \n    who acted in the matrix and what roles did they play?\n\nthe llm will generate the correct cypher:\n\n    match (m:movie {title: 'the matrix'})<-[:acted_in]-(a:actor)\n    return a.name as actor, a.role as role", "the llm will generate the correct cypher:\n\n    match (m:movie {title: 'the matrix'})<-[:acted_in]-(a:actor)\n    return a.name as actor, a.role as role\n\nhowever, the graph database returns no data because movies that start with `the` are renamed as `{title}, the`. `the matrix` is stored as `matrix, the`.\n\nyou can provide instructions to the llm to fix this problem.\n\n    for movie titles that begin with \"the\", move \"the\" to the end, for example \"the 39 steps\" becomes \"39 steps, the\" or \"the matrix\" becomes \"matrix, the\".\n\n[source, python]\n----\ncypher_generation_template = \"\"\"\nyou are an expert neo4j developer translating user questions into cypher to answer questions about movies and provide recommendations.\nconvert the user's question based on the schema.\n\ninstructions:\nuse only the provided relationship types and properties in the schema.\ndo not use any other relationship types or properties that are not provided.\nfor movie titles that begin with \"the\", move \"the\" to the end, for example \"the 39 steps\" becomes \"39 steps, the\" or \"the matrix\" becomes \"matrix, the\".\n\nschema: {schema}\nquestion: {question}\n\"\"\"\n----\n\nif you ask the llm the same question, it should now format the title correctly and return the correct data:\n\n    match (m:movie {title: 'matrix, the'})<-[:acted_in]-(a:actor)\n    return a.name as actor, a.role as role\n\n== controlling the response\n\nas well as instructing the llm on how to deal with the question, you can also instruct the llm on how to respond.", "== controlling the response\n\nas well as instructing the llm on how to deal with the question, you can also instruct the llm on how to respond.\n\nyou could instruct the llm only to respond when the cypher statement returns data.\n\n    if no data is returned, do not attempt to answer the question.\n\nyou may want the llm to only respond to questions in the scope of the task. for example:\n\n    only respond to questions that require you to construct a cypher statement.\n\n    do not respond to any questions that might ask anything else than for you to construct a cypher statement.\n\nconcise responses from the llm may be needed:\n\n    do not include any explanations or apologies in your responses.\n\nor you may want to restrict the format of the response:\n\n    do not include any text except the generated cypher statement.\n\nultimately, you must fine-tune your instructions for the specific task to ensure the best results.\n\n== check your understanding\n\ninclude::questions/1-instructions.adoc[leveloffset=+1]\n\n[.summary]\n== summary\n\nin this lesson, you learned something how to provide the llm with instructions to improve the responses to questions.\n\nin the next lesson, you will learn about few-shot examples and how they can improve the llm's performance.", "= few-shot examples\n:order: 3\n:type: lesson\n\neven though you have provided an llm with specific instructions, it can still make mistakes. \n\nin this lesson, you will learn about few-shot examples and how to use them to improve the performance of the llm.\n\nlink:https://www.promptingguide.ai/techniques/fewshot[few-shot prompting^] is a technique where you provide the llm with an example of how to respond or generate a response to a specific scenario.\n\n== example cypher\n\nhere is a use case demonstrating a problem that would benefit from few-shot prompting.\n\nyou ask the llm to generate a cypher statement to answer the question:\n\n    what movies has tom hanks directed and what are the genres?\n\nthe llm generates the following cypher statement:\n\n    match (p:person)-[:directed]->(m:movie) where p.name = 'tom hanks' return m.genres\n\nthe cypher statement returns the following result:\n\n    [{'genres': null}, {'genres': null}]\n\nfrom this data, the llm can understand that tom hanks has directed two movies, but there is no information about the genres of those movies.\n\nthe generated cypher statement is wrong because it uses the `m.genres` property, which doesn't exist. instead, it should follow the `:in_genre` relationship to `:genre` nodes and use the `.name` property.\n\nyou can improve the llm by providing an example of a correct cypher statement in the cypher generation prompt:\n\n    examples: \n\n    find movies and genres:\n    match (m:movie)-[:in_genre]->(g)\n    return m.title, g.name", "examples: \n\n    find movies and genres:\n    match (m:movie)-[:in_genre]->(g)\n    return m.title, g.name\n\n[%collapsible]\n.click to reveal the full cypher generation prompt\n====\n[source,python]\n----\ncypher_generation_template = \"\"\"\nyou are an expert neo4j developer translating user questions into cypher to answer questions about movies and provide recommendations.\nconvert the user's question based on the schema.\n\ninstructions:\nuse only the provided relationship types and properties in the schema.\ndo not use any other relationship types or properties that are not provided.\nfor movie titles that begin with \"the\", move \"the\" to the end, for example \"the 39 steps\" becomes \"39 steps, the\" or \"the matrix\" becomes \"matrix, the\".\n\nif no data is returned, do not attempt to answer the question.\nonly respond to questions that require you to construct a cypher statement.\ndo not include any explanations or apologies in your responses.\n\nexamples: \n\nfind movies and genres:\nmatch (m:movie)-[:in_genre]->(g)\nreturn m.title, g.name\n\nschema: {schema}\nquestion: {question}\n\"\"\"\n----\n====\n\nthe llm can use the example to help it generate the correct cypher statement:\n\n    match (p:person)-[:directed]->(m:movie)-[:in_genre]->(g:genre)\n    where p.name = 'tom hanks'\n    return distinct g.name\n\nwhich returns the correct data:\n\n    [{'g.name': 'drama'}, {'g.name': 'comedy'}, {'g.name': 'romance'}]", "which returns the correct data:\n\n    [{'g.name': 'drama'}, {'g.name': 'comedy'}, {'g.name': 'romance'}]\n\n[note]\n====\nthe few-shot example is not the complete cypher statement to answer the question, but it is enough to show the llm how to use the `[:in_genre]` relationship.\n====\n\nthe llm can now also generate the correct cypher statement for other questions involving movies and genres:\n\n    what genre of film is toy story?\n\n    match (m:movie {title: 'toy story'})-[:in_genre]->(g:genre)\n    return g.name\n\n    [{'g.name': 'adventure'}, {'g.name': 'animation'}, {'g.name': 'children'}, {'g.name': 'comedy'}, {'g.name': 'fantasy'}]\n\nfew-shot prompts allow you to provide targeted examples to the llm to improve its performance. providing examples can improve the llm's performance on a specific task or the performance in general. \n\n== check your understanding\n\ninclude::questions/1-few-shot-prompts.adoc[leveloffset=+1]\n\n[.summary]\n== summary\n\nin this lesson, you learned about few-shot prompting and how to use it to improve the performance of the llm.\n\nin the next optional challenge, you will add the cypher generation chain to an agent and give it conversation memory.", "= conversational agent\n:order: 4\n:type: challenge\n:optional: true\n\nduring this course, you have learned about the fundamentals of llms, how to interact with them using langchain, and how neo4j can support the llm in answering questions.\n\nin this optional challenge you will apply this new knowledge and skills to a new problem.\n\nyou will create a conversational agent using langchain that can answer questions about a topic you are interested in.\n\nthe agent should:\n\n* use a prompt that sets the scene for the llm\n* be given additional context that is relevant to the scenario\n* have conversational memory and be able to answer a string of questions\n* be given a few-shot example to support it in answering a specific type of question\n\ni recommend that you approach this challenge in the following order:\n\n. choose a topic that you are interested in\n. create a prompt and create a chain that uses the prompt\n. create an agent and add conversational memory\n. add additional context to the agent\n. add a few-shot example to the agent\n\n== next steps\n\nyou can learn more about creating chat bots using neo4j in the next graphacademy course - link:https://graphacademy.neo4j.com/courses/llm-chatbot-python/[build a neo4j-backed chatbot using python^].\n\nread::continue[]\n\n[.summary]\n== summary\n\nin this optional challenge, you used the knowledge and skills you have learned during this course to create a conversational agent.", "read::continue[]\n\n[.summary]\n== summary\n\nin this optional challenge, you used the knowledge and skills you have learned during this course to create a conversational agent.\n\ncongratulations on completing this course. i hope you have enjoyed it and learned a lot."]